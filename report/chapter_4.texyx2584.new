\chapter{Το {\en LensKit}}
\label{Chapter4}

\section{Εισαγωγή}

Το {\en LensKit} αποτελεί ένα ανοιχτού κώδικα πακέτο λογισμικού για την πραγματοποίηση μελέτης και επαληθεύσιμης έρευνας πάνω σε συστήματα παραγωγής συστάσεων. Αποτελεί μία πλατφόρμα για την ανάπτυξη αλγορίθμων παραγωγής συστάσεων, μέτρησης της επίδοσής τους πάνω σε διαφορετικά σύνολα δεδομένων και σύγκρισης νέων ιδεών με τις τρέχουσες βέλτιστες πρακτικές. \cite{ekstrand_towards_2014}\footnote{Πηγή του παρόντος κεφαλαίου ειναι το \cite{ekstrand_towards_2014}.} Υλοποιήθηκε από τον {\en Michael D. Ekstrand} και αναπτύχθηκε από ερευνητές στο {\en Texas State University} και στο πανεπιστήμιο της {\en Minnesota}, με συνεισφορά από προγραμματιστές από όλο τον κόσμο.\footnote{\en \url{http://lenskit.org/}} Αποτελείται από περισσότερες από 48Κ γραμμές κώδικα με συνεισφορά από 27 προγραμματιστές. Είναι γραμμένο κυρίως σε {\en Java} (92\%) και ένα σημαντικό μέρος του είναι σε {\en Groovy} (7\%).\footnote{Στατιστικά από \en BlackDuck | Open Hub \url{https://www.openhub.net/p/lenskit}} Ο πηγαίος κώδικας του {\en LensKit} είναι δημοσιευμένος στο {\en GitHub}.\footnote{\en \url{https://github.com/lenskit/lenskit}} \par 
Για το σκοπό που αναπτύχθηκε προσφέρει:
\begin{itemize}
 \item Διεπαφές προγραμματισμού εφαρμογών ({\en APIs}) για την παραγωγή συστάσεων και προβλέψεων. Επιτρέπει στους προγραμματιστές να χρησιμοποιήσουν τους υλοποιημένους αλγόριθμους ως ``μαύρο κουτί''.
 \item Υλοποίηση βασικών αλγορίθμων για παραγωγή συστάσεων και πρόβλεψη βαθμολογιών. 
 \item Εργαλειοθήκη αξιολόγησης απόδοσης σε κοινά σύνολα δεδομένων με χρήση ποικιλίας μετρικών.
 \item Κώδικα υποστήριξης για την ανάπτυξη νέων αλγορίθμων, μεθόδων αξιολόγησης και άλλων επεκτάσεων.
\end{itemize}
\par Ένας παραγωγός συστάσεων στο {\en LensKit} αποτελείται από ένα σύνολο διεπαφών που παρέχουν παραγωγή συστάσεων και πρόβλεψη βαθμολογιών, οι οποίες συνδέονται με μία πηγή δεδομένων χρησιμοποιώντας έναν ή περισσότερους αλγορίθμους παραγωγής συστάσεων. Η σύγκριση διαφορετικών αλγορίθμων γίνεται με τη χρήση {\en script} αφού δηλωθούν οι πηγές δεδομένων, οι αλγόριθμοι και οι μετρικές βάσει των οποίων συγκρίνονται.
\section{Σχεδιασμός του \en LensKit}
Ο σχεδιασμός του {\en LensKit} έγινε με στόχο τόσο την άναπτυξη και την έρευνα πάνω σε συστήματα παραγωγής συστάσεων όσο και τη χρήση του σε εκπαιδευτικούς σκοπούς. Το πανεπιστήμιο της {\en Minnesota} χρησιμοποιεί το {\en LensKit} τόσο σε μεταπτυχιακό του μάθημα όσο και σε {\en MOOC} πάνω σε συστήματα παραγωγής συστάσεων που προσέφερε μέσω της πλατφόρμας {\en Coursera}. To {\en LensKit} αναπτύχθηκε με τρόπο που να υποστηρίζει τη διεξαγωγή πειραμάτων.\cite{Konstan:2015:TRS:2744768.2728171} \par
Βασική αρχή στο {\en LensKit} είναι η υλοποίηση αλγορίθμων ως ένα σύνολο σχεδόν ανεξάρτητων τμημάτων. Ένας τυπικός αλγόριθμος αλγόριθμος, όπως και η υλοποίηση του αλγορίθμου {\en HIR} χρειάζεται τουλάχιστον δώδεκα διακριτά τμήματα ({\en components}) που επικοινωνούν μεταξύ τους μέσω καλώς ορισμένων διεπαφών. Αυτή η πρακτική διευκολύνει τη συντήρηση και τoν έλεγχο ορθότητας καθενός από τα συστατικά της υλοποίησης. \par
Βασικός στόχος είναι η διασφάλιση της ορθότητας και στη συνέχεια της αποτελεσματικότητας. Στο {\en LensKit} υπάρχουν πολλά αμετάβλητα αντικείμενα ({\en immutable objects}), ώστε να διασφαλίζεται ότι ένα τμήμα δε θα επηρεάζει αρνητικά τη λειτουργικότητα ενός άλλου. \par
Το {\en LensKit} ακολουθεί το μοτίβο στρατηγικής ({\en Strategy Pattern}). Στο μοτίβο αυτό κατά την ανάπτυξη μιας υλοποίησης δε χρησιμοποιείται η κληρονομικότητα. Αντί για υποκλάσεις που θα υλοποιούν τους διαφορετικούς τρόπους που μία κλάση θα επιτελεί κάποια λειτουργία της, χρησιμοποιείται η χρήση ξεχωριστών τμημάτων που ορίζονται από διεπαφές.\cite{Gamma:1995:DPE:186897} Η στρατηγική αυτή έχει ως άμεσο αποτέλεσμα οι επιμέρους αλλαγές στα τμήματα που υλοποιούν τις διεπαφές να μην απαιτούν αλλαγές στις κλάσεις που τα χρησιμοποιούν. Επιπρόσθετα, επιτρέπει την επανάχρηση των τμημάτων αυτών από άλλους αλγορίθμους μειώνοντας τον απαιτούμενο κώδικα για την υλοποίηση ενός αλγορίθμου, αλλά και βοηθώντας τον ερευνητή να επικεντρωθεί στην υλοποίηση που χρειάζεται για να ελέγξει την υπόθεσή του. \par
Παρά το ότι οι υλοποιημένοι αλγόριθμοι στο {\en LensKit} είναι εξαιρετικά διαμορφώσιμοι, δεν απαιτείται από το χρήστη να εμβαθύνει σε κάθε ξεχωριστό τμήμα, ώστε να τους χρησιμοποιήσει, καθώς όπου είναι δυνατό έχουν οριστεί προεπιλογές. 
\par Τέλος, κατά το σχεδιασμό του έχει γίνει προσπάθεια ελαχιστοποίησης των υποθέσεων που αφορούν στο είδος των δεδομένων που θα θελήσουν να χρησιμοποιήσουν οι χρήστες. Παρόμοια προσπάθεια γίνεται και όσον αφορά την υλοποίηση των ίδιων των αλγορίθμων όσο και τον αξιολογητή.
\section{Οργάνωση του κώδικα - Ενότητες}
Ο κώδικας οργανώνεται σε δέκα ενότητες ({\en modules}):
\begin{enumerate}
 \item {\en API}: Περιλαμβάνει τις διεπαφές για υψηλού επιπεδου εργασίες στην παραγωγή συστάσεων. Είναι ανεξάρτητο από τις υπόλοιπες ενότητες εκτός αυτής των δομών δεδομένων.
 \item Δομές Δεδομένων ({\en Data structures}: Περιλαμβάνει τις βασικές δομές δεδομένων του {\en LensKit}.
 \item Πηρύνας {\en Core}: Περιέχει το βασικό μέρος του LensKit, εκτός του αξιολογητή και των υλοποιήσεων των αλγορίθμων. Παρέχει υποστήριξη για τα δεδομένα και τη διαμόρφωση των αλγορίθμων.
 \item Αξιολογητής ({\en Evaluator}): Περιέχει υποστήριξη για την αξιολόγηση και τη σύγκριση αλγορίθμων με χρήση γνωστών μετρικών.
 \item Παραγωγοί Προβλέψεων ({\en Predictors}): Εξειδικευμένη υποστήριξη για την πρόβλεψη βαθμολογιών.
 \item {\en k-NN}: Συνεργατική Διήθηση πλησιέστερου γείτονα.
 \item {\en SVD}: Συνεργατική Διήθηση μέσω παραγοντοποίησης μητρώων. 
 \item {\en Slope1: Slope One} για πρόβλεψη σε συνεργατική διήθηση.
 \item {\en Grapht}: Εργαλειοθήκη για {\en Java} για την υλοποίηση ({\en dependency injection}).
 \item {\en CLI:} Διεπαφή γραμμής εντολών για εκτέλεση αλγορίθμων, χειρισμό αρχείων δεδομένων και επιθεώρηση διαμορφώσεων αλγορίθμων.
\end{enumerate}
\subsection{Recommender APIs}
 Δεν παρέχει κάποια υλοποίηση, αλλά χρησιμοποιείται για την ενθυλάκωση των διεπαφών των διαφόρων τμημάτων που υλοποιούν έναν παραγωγό συστάσεων.
   Κεντρικό τμήμα ενός παραγωγού συστάσεων είναι ο item scorer.
   Ο item scorer αποτελεί γενίκευση της παραγωγής προβλέψεων και υπολογίζει προσωποποιημένες ως προς το χρήστη κατατάξεις. 
   Υπάρχει η δυνατότητα παραγωγής προβλέψεων που δεν αφορούν βαθμολογίες των αντικειμένων.
   Έμμεση χρήση του item scorer και άμεση χρήση των item recommender και rating predictor.
   Διαχωρισμός item scorer και rating predictor.
   Σύνολα αντικειμένων στον item recommender.
 
 
\section{Μοντέλο Δεδομένων}
 
   Χρήστες, Αντικείμενα, Γεγονότα.
   Άμεσες βαθμολογίες και έμμεση εκδήλωση προτίμησης. 
   Αριθμητικά αναγνωριστικά (Java longs) για χρήστες και αντικείμενα (χωρίς περιορισμούς).
   Διαφορετικές διεπαφές (επεκτάσεις του βασικού τύπου) για κάθε τύπο γεγονότος. 
   Rating event, nullable, δυνατότητα πολλαπλών τιμών.
   Επικοινωνία των διαφόρων τμημάτων του παραγωγού συστάσεων με τα δεδομένα μεσω data access objects (DAOs).
   Ευελιξία όσον αφορά των τρόπο που είναι αποθηκευμένα τα δεδομένα.
   Βασικές μέδοδοι (επιστρέφουν βασικές δομές δεδομένων της Java) και streaming μέθοδοι (επιστρέφουν cursors).
   Αποδοτική διαχείριση μνήμης μέσω των streaming μεθόδων.
 
\subsection{Βασικές διεπαφές για {\en DAOs}}
 
   EventDAO, πρόσβαση σε stream γεγονότων. Μέθοδοι για streaming των γεγονότων σε βάση δεδομένων.
   ItemEventDAO, πρόσβαση και streaming γεγονότων σε βάση δεδομένων με κριτήριο κατηγοριοποίησης τα αντικείμενα.
   UserEventDAO.
   ItemDAO, πρόσβαση σε όλα τα αντικείμενα.
   UserDAO.
 
 Δυνατότητα επέκτασης των διεπαφών για αξιοποίηση μεταδεδομένων. Τα DAOs είναι τμήματα (components), όπως αυτά που επιτελούν τις λειτουργίες ενός παραγωγού συστάσεων.
\subsection{Δομές Δεδομένων}
 
   Sparse Vectors: αντιστοίχιση από long σε double, υποστήριξη πράξεων γραμμικής άλγεβρας.
   Είναι παράλληλοι πίνακες IDs και τιμών. Ταξινόμηση βάσει ID.
   Αποδοτική διαχείριση μνήμης, υλοποίηση αλγορίθμων και πράξεων.
   Αφηρημένη κλάση SparseVector, read-only μέθοδοι.
   ImmutableSparseVector, διασφαλίζει τη μη πραγματοποίηση αλλαγών στο διάνυσμα.
   ΜutableSparseVector
   Σταθερό σύνολο κλειδιών ή hash map και μετατροπή σε vector όταν αυτό δεν είναι εφικτό.
  Βιβλιοθήκη fastutil για συλλογές (collections) συμβατές με το Java collections API, η οποία επιτρέπει τη χρήση λιστών, συνόλων και maps από unboxed longs και doubles. Μείωση στη μνήμη που απαιτείται αλλά και του overhead από τη δέσμευση μνήμης.
  fast iteration για πολλές από τις δομές δεδομένων του LensKit και για το Cursor API.
  Google Guava
 
\subsection{Τα \en Sparse Vectors \el στο \en LensKit 3}
 
   Υπάρχει η πρόθεση να αντικατασταθούν είτε μέσω της διεπαφής αντιστοίχισης του fastutil (Long2DoubleMap) ή του LongDoubleMap του HPPC στο εσωτερικό του LensKit. Πιο πιθανό είναι το δεύτερο. Το HPPC είναι πιο μικρό από το fastutil και παρέχει αρκετά χρήσιμες μεθόδους.
   Δημιουργία ενός πακέτου συναρτήσεων για στατιστικές και αλγεβρικές πράξεις.
   Υλοποίηση μιας long-double αντιστοίχισης χρησιμοποιώντας τη στρατηγική τους για ταξινομημένους πίνακες, ώστε λόγους απόδοσης και καλής χρήσης της μνήμης. 
   Εξειδίκευση των στατιστικών και αλγεβρικών πράξεων, ώστε να λειτουργούν βέλτιστα με τη στρατηγική τους για ταξινομημένους πίνακες.
   Χρήση εξατομικευμένων αντιστοιχίσεων, builder των αντιστοιχίσεων και βελτιστοποιημένων στατιστικών πράξεων για λόγους ταχύτητας.
   Εξωτερικά υπάρχει η σκέψη να είναι όπως οι πίνακες (tables) δεδομένων της R.
   Ο χειρισμός των αποτελεσμάτων που επιστρέφονται από τους recommenders στα sparse vectors ή στα scored ids γίνεται μέσω ''side-channels'. Υπάρχει η σκέψη δημιουργίας νέων τύπων για τα αποτελέσματα μέσω εξατομικευμένων διεπαφών (και όχι αντιστοιχίσεων και λιστών). Αυτό θα ικανοποιήσει και την ανάγκη επιστροφής και χειρισμού περισσότερων πληροφοριών από τους recommenders εκτός των κατατάξεων.
\section{Modular αλγόριθμοι}
 
   Βασική αρχή σε όλες τις υλοποιήσεις είναι η τμηματοποίηση των αλγορίθμων, ώστε κάθε τμήμα να εκτελεί μία και μόνο λειτουργία με στόχο την επαναχρησιμοποίηση κώδικα και ευκολότερη παραμετροποίηση και ανάπτυξη κώδικα. Για το σκοπό αυτό παρέχει τις απαραίτητες διεπαφές.
   Διαχωρισμός των τμημάτων που περιέχουν τα δεδομένα (και συνοδεύονται από διεπαφές για την πρόσβαση σε αυτά) και αυτών που κάνουν υπολογισμούς για την παραγωγή (φαινομενικά αμετάβλητων) αντικειμένων.
   Για την επίτευξη των παραπάνω το LensKit χρησιμοποιεί dependency injection, δηλαδή ένα τμήμα κώδικα όταν καλείται πρέπει να του παρέχονται και τα αντικείμενα από τα αποία εξαρτάται αντί αυτά να ενεργοποιούνται από το ίδιο το τμήμα. Για το σκοπό αυτό το LensKit χρησιμοποιεί την εργαλειοθήκη Grapht.
   Παρέχονται προεπιλεγμένες τιμές για παραμέτρους και διεπαφές.
   Τα τμήματα χωρίζονται σε αυτά που είναι pre-built από τα δεδομένα και μπορούν να χρησιμοποιηθουύν από διαφορετικές κλήσεις και αυτά που χρειάζονται άμεση πρόσβαση στα δεδομένα.
\section{Βασικές Υλοποιήσεις αλγορίθμων}
 
   Λόγω της δομής του LensKit είναι δυνατόν να υλοποιηθεί κάποιος αλγόριθμος παραγωγής συστάσεων διαμορφώνοντας κάποιον υλοποιημένο item scorer ή υλοποιώντας μόνο το κομμάτι του αλγορίθμου που αφορά τον item scorer. 
   H προεπιλεγμένη υλοποίηση του item scorer είναι ο TopNItemRecommender. 
   Ο SimpleRatingPredictor υλοποιεί τον RatingPredictor χρησιμοποιώντας τον item scorer και αντιστοιχώντας τις παραγόμενες κατατάξεις στο επιτρεπόμενο εύρος τιμών χωρίς να πραγματοποιεί άλλη επεξεργασία σε αυτές. Επιπλέον ενσωματώνει κάποια άλλα τμήματα κώδικα τα οποία παράγουν βαθμολογίες με τη χρήση πχ προσωποποιημένου μέσου όρου ή μέσου όρου των αντικειμένων σε περίπτωση που ο item scorer δε μπορεί να προβλέψει βαθμολογίες. 
   Ο QuantizedRatingPredictor στρογγυλοποιεί τις κατατάξεις στην πλησιέστερη έγκυρη τιμή. 
\subsection{Παραγωγοί Περιλήψεων και κανονικοποιητές}
 
   Πολλά συστήματα δε χρησιμοποιούν άμεσες βαθμολογίες, όμως παράγουν ένα διάνυσμα που σχετίζεται με τις προτιμήσεις του χρήστη. Επίσης αυτό το διάνυσμα συχνά κανονικοποιείται ως προς το μέσο όρο των βαθμολογιών. 
   Ένας παραγωγός περιλήψεων ιστορικου παράγει από το ιστορικό γεγονότων του χρήστη ένα αραιό διάνυσμα προτιμήσεων του οποίου τα κλειδιά είναι τα αντικείμενα και οι τιμές είναι κάποιες πραγματικές τιμές που αντιπροσωπεύουν τις προτιμήσεις του χρήστη. Ο προεπιλεγμένος είναι ο RatingVectorUserHistorySummarizer και υπάρχει και ο EventCountUserHistorySummarizer. 
   Οι κανονικοποιητές εφαρμόζονται είτε πάνω στα διανύσματα αναφοράς είτε πάνω στα διανύσματα-στόχους. 
   Το διάνυσμα αναφοράς χρησιμοποιείται για τον υπολογισμό της βάσης της κανονικοποίησης και το διάνυσμα-στόχος είναι αυτό το οποίο τροποποιείται. 
   Για λόγους αντιστρεψιμότητας υπάρχει η δυνατότητα δημιουργίας ενός μετασχηματισμού από ένα διάνυσμα αναφοράς. Ο μετασχηματισμός μετά μπορεί να εφαρμοστεί σε οποιοδήποτε διάνυσμα.
   Υποστηρίζονται και στοχευμένοι ως προς τον χρήστη ή το αντικείμενο κανονικοποιητές. Οι κανονικοποιητές αυτή μπορούν να κάνουν χρήση επιπλέον πληροφορίας. Συχνά εξαρτώνται από DAOs για την πρόσβαση σε δεδομένα ή σε κάποιο άλλο τμήμα το οποίο μπορεί να επωφελήθεί απο τη γνώση για το ποιο διάνυσμα κανονικοποιείται.
\subsection{Βαθμολογητές Βάσης}
   Υπολογίζουν κατατάξεις για αντικείμενα με χρήση απλών μέσων όρων. Χρησιμοποιούνται τόσο για την παραγωγή κατατάξεων σε περίπτωση αποτυχίας του βασικού item scorer όσο και για κανονικοποίηση δεδομένων. Βασικοί αλγόριθμοι χρησιμοποιούν κανονικοποιημένα δεδομένα αντί για τις πραγματικές βαθμολογίες. 
   Η τελική βαθμολογία είναι της μορφής: $\text{score}(u, i) = b_{ui} + \text{score}^{'}(u, i)$.
   Οι Βαθμολογητές βάσης υλοποιούν τη διεπαφή του item scorer και οποιοσδήποτε item scorer μπορεί να χρησιμοποιηθεί ως βαθμολογητής βάσης. 
   ConstantItemScorer: Δίνει ως κατάταξη μια σταθερή τιμή για κάθε αντικείμενο.
   GlobalMeanRatingItemScorer: Αναθέτει ως κατάταξη το γενικό μέσο όρο των αντικειμένων ($b_{ui} =  \mu$).
   ItemMeanRatingItemScorer: Κάθε αντικείμενο παίρνει ως τιμή τον μέσο όρο βαθμολογιών του ($b_{ui} =  \mu_{i}$). Υποστηρίζει τη χρήση μιας damping παραμέτρου $\gamma$, ώστε αντικείμενα με λίγες βαθμολογίες να μην παίρνουν αδικαιολόγητα μεγάλες τιμές.
  \begin{center}
$\bar{\mu_{i}} = \frac{\sum_{u \in U_{i}}(r_{ui} - \mu)}{|U_i| + \gamma}$, $b_{ui} = \mu + \bar{\mu}_{i}$    
  \end{center}
  $\gamma > 0$ σημαίνει ότι το σύστημα υποθέτει ότι το αντικείμενο έχει $\gamma$ βαθμολογίες με τιμή το γενικό μέσο όρο. 
   UserMeanItemScorer: Εξαρτάται (συνήθως) από το βαθμολογητή βάσης μέσου όρου χρήστη, ο οποίος παράγει κατατάξεις $b^{'}_{ui}$ και 
έναν παραγωγό περιλήψεων, ο οποίος παράγει ένα διάνυσμα $\vec{u}$ των τιμών των αντικειμένων για τον χρήστη. Υπολογίζει τη μέση διαφορά $\hat{\mu}_{u}$ ανάμεσα στην τιμή του χρήστη για κάθε αντικείμενο και τη μέση τιμή από το βαθμολογητή βάσης γι'αυτό το αντικείμενο. Δίνει ως τιμή σε κάθε αντικείμενο τη τιμή βάσης του και το offset του χρήστη. Το $I_{u}$ είναι το σύνολο των αντικειμένων για το $\vec{u}$. 
\begin{center}
$\hat{\mu}_{u} = \frac{\sum_{i \in I_{u}} (u_{i} - b^{'}_{ui})}{|I_{u}| + \gamma}$, $b_{ui} = b^{'}_{ui} + \hat{\mu}_{u}$ 
\end{center}
 UserMeanItemScorer (συνέχεια): Αν ο χρήστης δεν έχει βαθμολογήσει ($\hat{\mu}_{u} = 0$), τότε ανατίθενται οι τιμές του υπολογιστή βάσης. Αν έχει χρησιμοποιηθεί ο βαθμολογητής βάσης μέσου όρου χρήστη ως ο βαθμολογητής βάσης και ο παραγωγός περιλήψεων δίνει το ιστορικό βαθμολογιών του χρήστη, τότε το $\hat{\mu}_{u}$ είναι η μέση διασπορά από το μέσο όρο των αντικειμένων και $b_{ui} = \mu + \bar{\mu}_{i} + \hat{\mu}_{u}$. Αν έχει χρησιμοποιηθεί ο γενικός μέσος όρος ως βαθμολογητής βάσης, τότε ο βαθμολογητής χρησιμοποιεί το μέσο όρο βαθμολογιών του χρήστη, ο οποίος εκφυλίζεται στο γενικό μέσο όρο όταν ο χρήστης δεν έχει βαθμολογίες.
\subsection{Συνεργατική Διήθηση Αντικειμένου-Αντικειμένου}
   Η συνεργατική διήθηση αντικειμένου-αντικειμένου ελέγχει το προφίλ του χρήστη και προτείνει παρόμοια αντικείμενα με αυτά για τα οποία έχει δείξει προτίμηση στο παρελθόν. 
   Υποστηρίζονται τόσο άμεσα όσο και έμμεσα δεδομένα για τα αντικείμενα. 
   Πυρήνας του είναι ο ItemItemScorer. 
   Συνδυάζει τα δεδομένα προτίμησης του χρήστη (από τον παραγωγό περιλήψεων) και τις γειτονιές αντικειμένων που δίνονται από ένα ItemItemModel. Κάθε γειτονιά αποτελείται από μια λίστα αντικειμένων με συσχετισμένες κατατάξεις ομοιότητας, ταξινομημένα σε μη αύξουσα σειρά. 
 \begin{center}
$\text{score}(u, i) = g^{-1}(f(i, N(i), g(\vec{u})))$ \\ $g(\vec{r}) = \vec{r} - \vec{b}_u$ \\ $\text{score}(u, i) = b_{ui}  + f(i, N(i), \vec{u} - \vec{b}_{u})$         
 \end{center}
   $\vec{b}_{u}$: οι βαθμολογίες βάσης για κάθε ένα από τα αντικείμενα στο ιστορικό $\vec{u}$ του χρήστη
   $N(i)$: η γειτονιά του αντικειμένου $i$, τυπικά περιορίζεται στα $n$ πιο παρόμοια αντικείμενα τα οποία εμφανίζονται και στο $\vec{u}$
   $f$ είναι η συνάρτηση υπολογισμού της γειτονιάς
   H $g$ είναι ο κανονικοποιητής. Αν είναι αφαιρέτης βάσης, τότε προκύπτει η δεύτερη συνάρτηση κατατάξεων.
    Ο υπολογισμός των κατατάξεων των αντικειμένων γίνεται σε ξεχωριστό τμήμα κώδικα (NeighborhoodScorer). To WeightedAverageNeighborhoodScorer υπολογίζει το μεσό όρο βαθμολογίας του χρήστη στα αντικείμενα της γειτονιάς και τον σταθμίζει με το βαθμό ομοιότητας ως προς το αντικείμενο-στόχο.
   \begin{center}
$f(i, N, \vec{u}^{'}) = \frac{\sum_{j \in N}\text{sim}(i, j)u^{'}_{j}}{\sum_{j \in N}|\text{sim}(i,j)|}$    
   \end{center}
Το SimilaritySumNeighborhood χρησιμεύει όταν έχουμε διαδικές τιμές στο διάνυσμα προτίμησης του χρήστη, αφού απλά προσθέτει τους βαθμούς ομοιότητας των αντικειμένων που εμφανίζονται στην περίληψη του ιστορικου του χρήστη. 
   Το προεπιλεγμένο ItemItemModel είναι το SimilarityMatrixModel, όπου αποθηκεύει μια αντιστοίχιση από το αναγνωριστικό του κάθε αντικειμένου στη λίστα γειτόνων του σε ένα ειδικό μη πλήρες αραιό μητρώο. Το μητρώο ομοιότητας παράγεται από το ItemItemModelBuilder και εξαρτάται από τη συνάρτηση ομοιότητας (ItemSimilarity διεπαφή) και από το ItemItemBuildContext, το οποίο αποτελείται από το κανονικοποιημένο και οργανωμένο ανά αντικείμενο μητρώο βαθμολογιών. Είναι μια αντιστοίχιση από τα αναγνωριστικά των αντικειμένων στα αραιά διανύσματα που περιέχουν τις βαθμολογίες των χρηστών. 
  Το ItemItemModelBuilder εκμεταλλεύεται τη συμμετρία και την αραιότητα (επιστρέφει 0 αν τα αντικείμενα δεν έχουν κοινούς χρήστες) της συνάρτησης ομοιότητας, εφόσον υπάρχουν.
  Συμμετρική και αραιή συνάρτηση είναι το συνημίτονο διανύσματος και μη συμμετρική η δεσμευμένη πιθανότητα.
  Συναρτήσεις που χρησιμοποιούν επιπλέον δεδομένα (πχ μεταδεδομένα) είναι συνήθως μη αραιές.
  Η ItemSimilarity διεπαφή διαθέτει μεθόδους για τον έλεγχο της συμπεριφοράς των συναρτήσεων.
 Η συμμετρία μειώνει τον αριθμό των απαιτούμενων υπολογισμών καθώς αφού υπολογίσει τη συμμετρία καταχωρεί το ένα αντικείμενο στη γειτονιά του άλλου.
   Η αραιότητα μειώνει τον αριθμό των συγκρίσεων που πραγματικά γίνονται. Σε περίπτωση που δεν υπάρχει πραγματικά αραιότητα ή η εκμετάλλευση της ιδιότητας επιφέρει αύξηση των υπολογισμών κατά τη διάρκεια των υπολογισμών σταματά η προσπάθεια να γίνει χρήση της ιδιότητας αυτής. 
   Επιτρέπεται ο περιορισμός του αριθμού των γειτόνων (@ModelSize) που επιτρέπονται για κάθε αντικείμενο. Εσωτερικά το μοντέλο δεδομένων αποθηκεύει τους γείτονες σε έναν σωρό (heap), ώστε να τους προσπελαύνει αποδοτικά. 
   Επιτρέπεται ο καθορισμός ενός ορίου ομοιότητας (Threshold) όπου αποθηκεύονται μόνο οι γείτονες που το περνούν. 
   Δίνεται επιπλέον η δυνατότητα κανονικοποίησης (πχ μοναδιαίο διάνυσμα) του διανύσματος της γειτονιάς του κάθε αντικειμένου. Σε αυτή την περίπτωση δε λαμβάνονται υπόψη οι ιδιότητες συμμετρίας, αραιότητας και ο σωρός. 
 Συνοπτικά:
   O ItemItemBuildContextBuilder παράγει την περίληψη των προφίλ των χρηστών, τα κανονικοποιεί και παράγει το ItemItemBuildContext, το οποίο είναι ένα μητρώο προτιμήσεων των χρηστών ευρετηριοποιημένο σε σχέση με τις βαθμολογίες τους. 
   Ο ItemItemModelBuilder χρησιμοποιεί το περιεχόμενο και το ItemSimilarity για να παράξει ένα μητρώο ομοιότητας των αντικειμένων, το οποίο υλοποιεί το ItemItemModel.
   Το προεπιλεγμένο ItemSimilarity αγνοεί τα αναγνωριστικά των αντικειμένων και εκφυλίζεται σε ένα VectorSimilarity.
   Ο ItemItemScorer χρησιμοποιεί το ItemItemModel, το UserHistorySummarizer και το UserEventDAO για να ανακτήσει το προφίλ του χρήστη και να ταξινομήσει τα αντικείμενα βάσει της ομοιότητάς τους με αντικείμενα που έχει ήδη προτιμήσει ο χρήστης. 
  \subsection{Συνεργατική Διήθηση Χρήστη-Χρήστη}
   Προτείνει αντικείμενα σε κάποιον χρήστη ψάχνοντας για χρήστες με παρόμοιες προτιμήσεις κατασκευάζοντας γειτονιές χρηστών συχνά με χρήση του σταθμισμένου μέσου όρου των βαθμολογιών των γειτόνων.
   Δεν κάνει χρήση του model.
   Δεν έχει επεκταθεί σε έμμεσα δεδομένα. 
   Πυρήνας του είναι ο UserUserItemScorer, ο οποίος χρησιμοποιεί τα UserEventDAO, UserVectorNormalizer και NeighborFinder.
   Ο NeighborFinder δέχεται ως είσοδο το προφίλ ενός χρήστη και ένα σύνολο αντικειμένων προς κατάταξη. Επιστρέφει μια συλλογή πιθανών γειτόνων. Κάθε αντικείμενο γείτονα αναπαριστά ένα χρήστη με το διάνυσμα βαθμολογιών του και την ομοιότητά του σε σχέση με τον χρήστη. 
  \begin{center}
  $\text{score}(u,i) = \text{denorm}(\frac{\sum_{v \in N(u,i)}\text{sim}(\tilde{u}, \tilde{v})\tilde{r}_{vi}}{\sum_{v\in N(u,i)}|\text{sim}(\tilde{u}, \tilde{v})|};u)$ 
  \end{center}
  $\vec{u}$: η κανονικοποιημένη έκδοση ενός χρήστη $u$ ή μιας τιμής βαθμολογίας.
 
   Ο NeighborFinder ελέγχει τη βάση δεδομένων των γεγονότων για πιθανούς γείτονες. 
   Εξαιρεί όσους δεν έχουν βαθμολογήσει κανένα αντικείμενο από τα προς βαθμολόγηση ή από αυτά που έχει ήδη βαθμολογήσει ο χρήστης. 
   Για λόγους βελτιστοποίησης, χρησιμοποιείται το μικρότερο από τα παραπάνω σύνολα αντικειμένων.
   Τέλος, υπάρχει υλοποίηση με χρήση snapshot των βαθμολογιών.
   H UserSimilarity διεπαφή παρέχει συναρτήσεις ομοιότητας.
\subsection{Συνεργατική Διήθηση μέσω Παραγοντοποίησης Μητρώων}
 
   Η υλοποίηση που προσφέρει το LensKit είναι παρόμοια με την SVD.
   Από το μητρώο των βαθμολογιών $\mathbf{R}$ αφαιρούνται οι κατατάξεις βάσης και στη συνέχεια υπολογίζεται η biased SVD.
   $\mathbf{R} = \mathbf{B} + \mathbf{WΣX}^{\text{T}}$
   Η αρχιτεκτονική του LensKit επιτρέπει την ενσωμάτωση άλλων αλγορίθμων παραγοντοποίησης.
   Προεπιλεγμένη μέθοδος μάθησης των μητρώων είναι η gradient decent.
   Το πακέτο παραγοντοποίησης μητρώων διαχωρίζει τη χρήση της από τον τρόπο υπολογισμού της.
   MFModel: Εκθέτει τα μητρώα των χρηστών και αντικειμένων (χ/α). Αποθηκεύει αντιστοιχίσεις μεταξύ των αναγνωριστικών χ/α και των αντίστοιχων γραμμών και στηλών των μητρώων. Το $\mathbf{Σ}$ είναι ενσωματωμένο στα μητρώα χ/α. 
   BiasedMFKernel: Η διεπαφή για τις kernel συναρτήσεις για τον υπολογισμό της τελικής κατάταξης. Η προεπιλεγμένη υλοποίηση (DotProductKernel) υπολογίζει: $\text{score}(u,i) = b_{ui} + \mathbf{w}_{(u)} \cdot \mathbf{x}_{(i)}$.
   DomainClampingKernel: Μετά από κάθε πρόσθεση διορθώνει την τιμή, ώστε να είναι στο επιτρεπτό εύρος τιμών.
   BiasedMFItemScorer: Αποτελεί την υλοποίηση της διεπαφής του ItemScorer χρησιμοποιώντας έναν βαθμολογητή βάσης, το MFModel και τον BiasedMFKernel.
   Η γενική παραγοντοποίηση μπορεί να παράξει κατατάξεις, αλλά δε μαθαίνει το μοντέλο.
   Η regularized gradient decent (FunkSVD) προσθέτει αυτή τη λειτουργικότητα.
   Ο FunkSVDModelBuilder κατασκευάζει το FunkSVDModel (υποκλάση του MFModel) χρησιμοποιώντας gradient decent στις βαθμολογίες του συστήματος. Μαθαίνει ένα χαρακτηριστικό κάθε φορά και αφού συγκλίνει προχωράει στο επόμενο. 
   Χρησιμοποιεί ένα ρυθμό εκμάθησης $\lambda$, ένα regularized συντελεστή $\gamma$ και μια συνθήκη τερματισμού (συνήθως έναν αριθμό εποχών ή ένα κατώφλι).
   Η παραγοντοποίηση αυτή δεν είναι καλώς ορισμένη και το μητρώο $\mathbf{Σ}$ εξάγεται από τα $\mathbf{W}$ και $\mathbf{X}$ θέτωντας
  \begin{center}
   $\sigma_{f} = \|\mathbf{w}_{(f)}\|_{2}\|\mathbf{x}_{(f)}\|_{2}$
  \end{center}
   Το αριστερό και το δεξί μητρώο δε σχηματίζουν ορθοκανονική βάση.
   Η κανονική SVD μέθοδος και αρκετές τεχνικές όπως η ανανέωση των διανυσμάτων χ/α δε λειτουργούν σωστά.
   Ο BiasedMFItemScorer δεν ανανεώνει τα διανύσματα χ/α. Αν ο χρήστης δεν έχει διάνυσμα χαρακτηριστικών επιστρέφει τις βαθμολογίες βάσης. 
   Ο FunkSVDItemScorer χρησιμοποιώντας gradient decent στο διάνυσμα βαθμολογιών ανανεώνει το διάνυσμα χαρακτηριστικών πριν παράξει κατατάξεις. Για νέους χρήστες χρησιμοποιεί το μέσο βάρος χρηστών για κάθε χαρακτηριστικό ως σημείο εκκίνησης. 
   Ο FunkSVDItemBuilder χρησιμοποιεί μια βοηθητική δομή (PackedPreferenceSnapshot) για την αναπαράσταση των δεδομένων τα οποία εκπαιδεύει. Τα snapshot φτιάχνονται απευθείας από τα δεδομένα βαθμολογιών.
\subsection{Διαμόρφωση αλγορίθμων}
 Μέσω του Grapht API.
   Με τη χρήση μιας ενσωματωμένης scripting γλώσσας σε Groovy. 
   Πιο ''ελαφριά'' σύνταξη σε σχέση με τη Java.
   Δίνει τη δυνατότητα οι ορισμοί των αλγορίθμων να αντιμετωπίζονται ως configuration αρχεία και να μην είναι ενσωματωμένα στον κώδικα των εφαρμογών.
   Η γραμμή εντολών του LensKit μπορεί να χειριστεί αυτά τα script.
\subsection{Αξιολόγηση αλγορίθμων και Σύνολα Δεδομένων}
   Υποστηρίζεται offline, προσανατολισμένη στα δεδομένα αξιολόγηση της απόδοσης μέσω εκπαίδευσης και ελέγχου με cross-validation.
   Yποστηρίζεται επεξεργασία των συνόλων δεδομένων και αξιολόγηση αλγορίθμων πάνω σε πολλαπλά σύνολα δεδομένων και μέτρηση της απόδοσής τους. 
   Στο LensKit 3 θα γίνεται μέσω του CLI και του Grandle. 
   Ο αξιολογητής χειρίζεται δεδομένα κυρίως σε μορφή delimited αρχείων κειμένου και δυαδικών αρχείων βαθμολογιών.
   Οι βασικές εργασίες χειρισμού δεδομένων είναι: 
    crossfold: Διαχωρισμός της πηγής δεδομένων σε Ν τμήματα για cross-validation.
    subsample: Δημιουργία ενός μικρότερου συνόλου δεδομένων με τυχαία επιλογή από ένα μεγαλύτερο βάσει κριτηρίου. 
    pack: Μετατροπή ενός συνόλου δεδομένων σε δυαδικό αρχείο για αποδοτική πρόσβαση.
   
 \subsection{Aξιολόγηση Αλγορίθμων και Mετρικές Απόδοσης}
 
   Ο αξιολογητής δέχεται ένα σύνολο αλγορίθμων και σύνολα δεδομένων εκπαίδευσης και ελέγχου και αξιολογεί την ακρίβεια κάθε αλγορίθμου πάνω σε κάθε ζεύγος δεδομένων εκπαίδευσης και ελέγχου. Οι διαθέσιμες μετρικές είναι:
    MAE: Μέσο απόλυτο σφάλμα των προβλεφθέντων δεδομένων βαθμολόγησης στα σύνολα ελέγχου. Οι μη προβλεφθείσες βαθμολογίες αγνοούνται.
    RMSE: Διασπορά ανάμεσα στις προβλεφθείσες και τις πραγματικές βαθμολογίες. Οι μη προβλεφθείσες βαθμολογίες αγνοούνται.
    Coverage (predict): Μετράει τον αριθμό των παρεχόμενων προβλέψεων βαθμολογιών σε σχέση με το σύνολο των ζητούμενων.
    Predict nDCG: Κανονικοποιημένο μειούμενο συσσωρευτικό όφελος. Υπολογίζεται από την κατάταξη των προβλεφθέντων βαθμολογιών χρησιμοποιώντας τις πραγματικές βαθμολογίες ως όφελος.
    Predict half-life utility: nDCG με συνάρτηση μείωσης το χρόνο ημιζωής. Έχει το πλεονέκτημα ότι μπορεί να χρησιμοποιηθεί σε ένα πιθανοτικό μοντέλο της συμπεριφοράς του χρήστη. Επιπλέον μειώνει το όφελος και στο δεύτερο αντικείμενο, καθώς με τη χρήση λογαρίθμου στη συνάρτηση μείωσης τα $b$ πρώτα αντικείμενα έχουν το μέγιστο βάρος, όπου $b$ η βάση του λογαρίθμου.
    Top-N nDCG: nDCG σε σταθερού μήκους λίστες συστάσεων.
    Top-N Precision and Recall: Ακρίβεια και ανάκληση σε σταθερού μήκους λίστες συστάσεων.
   Παρέχεται υποστήριξη για την εκτέλεση παράλληλων υλοποιήσεων.
   Αναγνωρίζονται και διαμοιράζονται τα κοινά τμήματα μεταξύ διαφορετικών διαμορφώσεων αλγορίθμων.
 
Τα χαρακτηριστικά αυτά δίνουν τη δυνατότητα εκμετάλλευσης πολυπύρηνων αρχιτεκτονικών διαμοιραζόμενης μνήμης για την αξιολόγηση αλγορίθμων παραγωγής συστάσεων.
\subsection*{Dependency Injection}
 
   Πριν την αρχικοποίηση ενός αντικειμένου, όλες οι εξαρτήσεις πρέπει να είναι διαθέσιμες. Για την επίτευξη αυτού έχουν αναπτυχθεί εργαλειοθήκες, οι dependency injectors, οι οποίοι κάνουν αυτόματα την απαραίτητη διαδικασία. 
   Το Grapht ακολουθεί πολιτική ευαίσθητη ως προς το περιεχόμενο, επιτρέποντας στα αντικείμενα να διαμορφώνονται βάσει του πού χρησιμοποιούνται.
   Διαχωρίζει την επίλυση εξάρτησης από την δημιουργία των στιγμιοτύπων των αντικειμένων και εκθέτει το γράφημα των επιλυμένων εξαρτήσεων των αντικειμένων ως ένα αντικείμενο που μπορεί να αναλυθεί και να διαχειρισθεί. 
   Πολλά από τα χαρακτηριστικά του είναι υλοποιημένα με όρους μετασχηματισμού γραφημάτων. 
  Dependency injection είναι σχεδιασμός που προκύπτει από την εφαρμογή αντιστροφής ελέγχου (Inversion of Control) στο πρόβλημα της δημιουργίας στιγμιοτύπων αντικειμένων που εξαρτώνται από άλλα. 
  Μέσω αυτού αν ένα αντικείμενο Α εξαρτάται από ένα αντικείμενο Β, μπορεί να ζητήσει να του παρασχεθεί το Β μέσω ενός ορίσματος στο δημιουργό του. 
  Έτσι, τα τμήματα κώδικα δε γνωρίζουν για τη υλοποίηση των εξαρτήσεών τους.
  Τα τμήματα κώδικα μπορούν να επαναδιαμορφωθούν με αλλαγή των υλοποιήσεων των εξαρτήσεών τους, χωρίς να αλλάξουν τα ίδια.
  Διευκολύνεται ο έλεγχος λειτουργίας τους. 
  Οι εξαρτήσεις κάθε τμήματος δηλώνονται με άμεσο τρόπο. 



